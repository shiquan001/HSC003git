/*
*********************************************************************************************************
*
*	??????? : ????????
*	??????? : bsp_timer.c
*	??    ?? : V1.2
*	?    ?? : ????TIM4???????????未??????TIM1??TIM2?????????????TIM4??????????????????TIM1
*			   ??TIM2??????????????????????????????????? TIM4????未??????????????1ms??
*
*				?????4???????????????????????(????10ms)
*				?????ms????????????????2ms??
*				?????us??????????
*				?????????????浜????10ms??位??
*
*	????? :
*		?姹??  ????       ????    ???
*		v1.0    2012-10-12 armfly  ST?????姹?V2.1.0
*		v1.1    2014-06-22 armfly  ??? bsp_DelayUS?? ???16M??? 2000us??? 1.9ms
*		V1.2	2014-09-11 armfly  ????TIM2 ?????????????us??????????????3??CC??????????3??????
*									?????????????????????????????????????
*
*	Copyright (C), 2012-2013, ?????????? www.armfly.com
*
*********************************************************************************************************
*/


#include "stm32l4xx_hal.h"
#include "bsp_timer.h"
#include "bsp.h"


#define ENABLE_SYSTICK_INT()	//enableInterrupts()//TIM4_ITConfig(TIM4_IT_UPDATE, ENABLE)
#define DISABLE_SYSTICK_INT()	//disableInterrupts()//TIM4_ITConfig(TIM4_IT_UPDATE, DISABLE)

/*
	??????????????????????????
	???????????__IO ?? volatile???????????????卸????????????????????锌????????????????????
*/

static __IO uint32_t s_uiDelayCount = 0;
static __IO uint8_t s_ucTimeOutFlag = 0;

SOFT_TMR g_Tmr[TMR_COUNT];

/* ????????????位1ms */
 uint32_t g_iRunTime = 0;
#if 0
/* ???? TIM2????卸??????械?????????? */
static void (*s_TIM2_CallBack1)(void);
static void (*s_TIM2_CallBack2)(void);
static void (*s_TIM2_CallBack3)(void);
static void TIM4_Config(void);
#endif
static void bsp_SoftTimerDec(SOFT_TMR *_tmr);

/*
*********************************************************************************************************
*	?? ?? ??: SysTick_ISR
*	???????: SysTick?卸??????????2ms????1??
*	??    ?危???
*	?? ?? ?: ??
*********************************************************************************************************
*/
void bsp_InitTimer(void)
{
	uint8_t i;

	/*
		STM8S ?????????????????HSI RC???(16MHz)??8???????fHSI/8 = 2MHz
	*/
	//bsp_ConfgiSysClk(CPU_SYS_CLK_INIT);		/* ???????? */

	/* ???????械?????????? */
	for (i = 0; i < TMR_COUNT; i++)
	{
		g_Tmr[i].Count = 0;
		g_Tmr[i].PreLoad = 0;
		g_Tmr[i].Flag = 0;
		g_Tmr[i].Mode = TMR_ONCE_MODE;	/* ????1????????? */
	}

	//TIM4_Config();
}

/*
*********************************************************************************************************
*	?? ?? ??: SysTick_ISR
*	???????: SysTick?卸??????????2ms????1??
*	??    ?危???
*	?? ?? ?: ??
*********************************************************************************************************
*/
extern void bsp_RunPer10ms(void);
extern void bsp_RunPer1ms(void);

void SysTick_ISR(void)
{
	static uint8_t s_count = 0;
	uint8_t i;
	#if 0
	TIM4_ClearITPendingBit(TIM4_IT_UPDATE);
	#endif
	//TIM4_ClearFlag(TIM4_FLAG_UPDATE);

	/* ???1ms????1?? */
	if (s_uiDelayCount > 0)
	{
		if (--s_uiDelayCount == 0)
        {
			s_ucTimeOutFlag = 1;
		}
	}

	/* ???1ms ??????? */
	for (i = 0; i < TMR_COUNT; i++)
	{
		bsp_SoftTimerDec(&g_Tmr[i]);
	}
	
	g_iRunTime++;	/* ???????????1ms??1,  24.8???????? */

	bsp_RunPer1ms();	/* ??????? bsp.c ?????(???????) */
		
	if (++s_count < (10 / SYSTICK_PERIOD))
	{
		return;
	}

	s_count = 0;

	bsp_RunPer10ms();	/* ??????? bsp.c ?????(???????) */
}

/*
*********************************************************************************************************
*	?? ?? ??: bsp_SoftTimerDec
*	???????: ?????卸??????????1??????SysTick_ISR????????谩?
*	??    ?危?_tmr : ????????????
*	?? ?? ?: ??
*********************************************************************************************************
*/
static void bsp_SoftTimerDec(SOFT_TMR *_tmr)
{
//	if (_tmr->Flag == 0)
	{
		if (_tmr->Count > 0)
		{
			/* ????????????????1???????????????? */
			if (--_tmr->Count == 0)
			{
				_tmr->Flag = 1;

				/* ?????????????????????????? */
				if(_tmr->Mode == TMR_AUTO_MODE)
				{
					_tmr->Count = _tmr->PreLoad;
				}
			}
		}
	}
}

/*
*********************************************************************************************************
*	?? ?? ??: bsp_DelayMS
*	???????: ms?????????????????2ms
*	??    ?危?n : ?????????位1 ms?? n ?????2
*	?? ?? ?: ??
*********************************************************************************************************
*/
void bsp_DelayMS(uint32_t n)
{
	if (n == 0)
	{
		return;
	}
	else if (n == 1)
	{
		n = 2;
	}

	DISABLE_SYSTICK_INT();  			/* ???卸? */
	s_uiDelayCount = n / SYSTICK_PERIOD;
	s_ucTimeOutFlag = 0;
	ENABLE_SYSTICK_INT();  				/* ???卸? */

	while (1)
	{
		bsp_Idle();

		/* ????????? */
		/* ???????????? s_ucTimeOutFlag = 0????????????????
		??? s_ucTimeOutFlag ?????????????_IO_?? */
		if (s_ucTimeOutFlag == 1)
		{
			break;
		}
	}
}

/*
*********************************************************************************************************
*	?? ?? ??: bsp_StartTimer
*	???????: ???????????????????????????
*	??    ?危?	_id     : ?????ID?????0,TMR_COUNT-1???????????????????????ID??????????ID?????
*				_period : ??????????位10ms
*	?? ?? ?: ??
*********************************************************************************************************
*/
void bsp_StartTimer(uint8_t _id, uint32_t _period)
{
	if (_id >= TMR_COUNT)
	{
		/* while(1); ???? */
		return;
	}

	_period = _period / SYSTICK_PERIOD;
	if (_period == 0)
	{
		_period = 1;
	}
	
	DISABLE_SYSTICK_INT();  			/* ???卸? */

	g_Tmr[_id].Count = _period;			/* ??????????? */
	g_Tmr[_id].PreLoad = _period;		/* ???????????????????????????? */
	g_Tmr[_id].Flag = 0;				/* ????????? */
	g_Tmr[_id].Mode = TMR_ONCE_MODE;	/* 1????????? */

	ENABLE_SYSTICK_INT();  				/* ???卸? */
}

/*
*********************************************************************************************************
*	?? ?? ??: bsp_StartAutoTimer
*	???????: ??????????????????????????????
*	??    ?危?	_id     : ?????ID?????0,TMR_COUNT-1???????????????????????ID??????????ID?????
*				_period : ??????????位10ms
*	?? ?? ?: ??
*********************************************************************************************************
*/
void bsp_StartAutoTimer(uint8_t _id, uint32_t _period)
{
	if (_id >= TMR_COUNT)
	{
		/* while(1); ???? */
		return;
	}

	_period = _period / SYSTICK_PERIOD;
	if (_period == 0)
	{
		_period = 1;
	}
	
	DISABLE_SYSTICK_INT();  		/* ???卸? */

	g_Tmr[_id].Count = _period;			/* ??????????? */
	g_Tmr[_id].PreLoad = _period;		/* ???????????????????????????? */
	g_Tmr[_id].Flag = 0;				/* ????????? */
	g_Tmr[_id].Mode = TMR_AUTO_MODE;	/* ????????? */

	ENABLE_SYSTICK_INT();  		/* ???卸? */
}

/*
*********************************************************************************************************
*	?? ?? ??: bsp_StopTimer
*	???????: ??????????
*	??    ?危?	_id     : ?????ID?????1,TMR_COUNT-1???????????????????????ID??????????ID?????
*						  ?????ID = 0 ??????bsp_DelayMS()????
*	?? ?? ?: ??
*********************************************************************************************************
*/
void bsp_StopTimer(uint8_t _id)
{
	if (_id >= TMR_COUNT)
	{
		/* while(1); ???? */
		return;
	}

	DISABLE_SYSTICK_INT();  	/* ???卸? */

	g_Tmr[_id].Count = 0;				/* ??????????? */
	g_Tmr[_id].Flag = 0;				/* ????????? */
	g_Tmr[_id].Mode = TMR_ONCE_MODE;	/* ????????? */

	ENABLE_SYSTICK_INT();  		/* ???卸? */
}

/*
*********************************************************************************************************
*	?? ?? ??: bsp_CheckTimer
*	???????: ??????????
*	??    ?危?	_id     : ?????ID?????0,TMR_COUNT-1???????????????????????ID??????????ID?????
*	?? ?? ?: ???? 0 ??????未???? 1????????
*********************************************************************************************************
*/
uint8_t bsp_CheckTimer(uint8_t _id)
{
	if (_id >= TMR_COUNT)
	{
		return 0;
	}

	if (g_Tmr[_id].Flag == 1)
	{
		g_Tmr[_id].Flag = 0;
		return 1;
	}
	else
	{
		return 0;
	}
}

/*
*********************************************************************************************************
*	?? ?? ??: bsp_SetTimer
*	???????: ????id
*	??    ?危?	_id     : ?????ID?????0,TMR_COUNT-1???????????????????????ID??????????ID?????
*	?? ?? ?: ???? 0 ??????未???? 1????????
*********************************************************************************************************
*/
uint8_t bsp_SetTimer(uint8_t _id)
{
	if (_id >= TMR_COUNT)
	{
		return 0;
	}

	//if (g_Tmr[_id].Flag == 1)
	{
		g_Tmr[_id].Flag = 1;
		return 1;
	}

}

/*
*********************************************************************************************************
*	?? ?? ??: bsp_GetRunTime
*	???????: ???CPU???????
*	??    ?危???
*	?? ?? ?: CPU?????????位10ms
*********************************************************************************************************
*/
uint32_t bsp_GetRunTime(void)
{
	uint16_t runtime;

	DISABLE_SYSTICK_INT();  		/* ???卸? */

	runtime = g_iRunTime;	        /* ??????Systick?卸????写???????卸???斜??? */

	ENABLE_SYSTICK_INT();  		    /* ???卸? */

	return runtime;
}
#if 0

/*
*********************************************************************************************************
*	函 数 名: bsp_InitHardTimer
*	功能说明: 配置 TIMx，用于us级别硬件定时。TIMx将自由运行，永不停止.
*			TIMx可以用TIM2 - TIM5 之间的TIM, 这些TIM有4个通道, 挂在 APB1 上，输入时钟=SystemCoreClock / 2
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void bsp_InitHardTimer(void)
{
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	uint32_t usPeriod;
	uint16_t usPrescaler;
	uint32_t uiTIMxCLK;

	/* 使能TIM时钟 */
	RCC_APB1PeriphClockCmd(TIM_HARD_RCC, ENABLE);

	/*-----------------------------------------------------------------------
		system_stm32f4xx.c 文件中 void SetSysClock(void) 函数对时钟的配置如下：

		HCLK = SYSCLK / 1	  (AHB1Periph)
		PCLK2 = HCLK / 2	  (APB2Periph)
		PCLK1 = HCLK / 4	  (APB1Periph)

		因为APB1 prescaler != 1, 所以 APB1上的TIMxCLK = PCLK1 x 2 = SystemCoreClock / 2;
		因为APB2 prescaler != 1, 所以 APB2上的TIMxCLK = PCLK2 x 2 = SystemCoreClock;

		APB1 定时器有 TIM2, TIM3 ,TIM4, TIM5, TIM6, TIM7, TIM12, TIM13,TIM14
		APB2 定时器有 TIM1, TIM8 ,TIM9, TIM10, TIM11

	----------------------------------------------------------------------- */
	uiTIMxCLK = SystemCoreClock / 2;

	usPrescaler = uiTIMxCLK / 1000000 ; /* 分频到周期 1us */

#if defined (USE_TIM2) || defined (USE_TIM5) 
	usPeriod = 0xFFFFFFFF;
#else
	usPeriod = 0xFFFF;
#endif
	/* Time base configuration */
	TIM_TimeBaseStructure.TIM_Period = usPeriod;
	TIM_TimeBaseStructure.TIM_Prescaler = usPrescaler;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;

	TIM_TimeBaseInit(TIM_HARD, &TIM_TimeBaseStructure);

	//TIM_ARRPreloadConfig(TIMx, ENABLE);

	/* TIMx enable counter */
	TIM_Cmd(TIM_HARD, ENABLE);

	/* 配置TIM定时中断 (Update) */
	{
		NVIC_InitTypeDef NVIC_InitStructure;	/* 中断结构体在 misc.h 中定义 */

		NVIC_InitStructure.NVIC_IRQChannel = TIM_HARD_IRQn;

		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;	/* 比串口优先级低 */
		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
		NVIC_Init(&NVIC_InitStructure);
	}
}


/*
*********************************************************************************************************
*	函 数 名: bsp_StartHardTimer
*	功能说明: 使用TIM2-5做单次定时器使用, 定时时间到后执行回调函数。可以同时启动4个定时器，互不干扰。
*             定时精度正负10us （主要耗费在调用本函数的执行时间，函数内部进行了补偿减小误差）
*			 TIM2和TIM5 是32位定时器。定时范围很大
*			 TIM3和TIM4 是16位定时器。
*	形    参: _CC : 捕获通道几，1，2，3, 4
*             _uiTimeOut : 超时时间, 单位 1us.       对于16位定时器，最大 65.5ms; 对于32位定时器，最大 4294秒
*             _pCallBack : 定时时间到后，被执行的函数
*	返 回 值: 无
*********************************************************************************************************
*/
void bsp_StartHardTimer(uint8_t _CC, uint32_t _uiTimeOut, void * _pCallBack)
{
    uint32_t cnt_now;
    uint32_t cnt_tar;

    /*
        执行下面这个语句，时长 = 18us (通过逻辑分析仪测量IO翻转)
        bsp_StartTimer2(3, 500, (void *)test1);
    */
    if (_uiTimeOut < 5)
    {
        ;
    }
    else
    {
        _uiTimeOut -= 5;
    }

    cnt_now = TIM_GetCounter(TIM_HARD);    	/* 读取当前的计数器值 */
    cnt_tar = cnt_now + _uiTimeOut;			/* 计算捕获的计数器值 */
    if (_CC == 1)
    {
        s_TIM_CallBack1 = (void (*)(void))_pCallBack;

        TIM_SetCompare1(TIM_HARD, cnt_tar);      	/* 设置捕获比较计数器CC1 */
        TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC1);
		TIM_ITConfig(TIM_HARD, TIM_IT_CC1, ENABLE);	/* 使能CC1中断 */

    }
    else if (_CC == 2)
    {
		s_TIM_CallBack2 = (void (*)(void))_pCallBack;

        TIM_SetCompare2(TIM_HARD, cnt_tar);      	/* 设置捕获比较计数器CC2 */
		TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC2);
		TIM_ITConfig(TIM_HARD, TIM_IT_CC2, ENABLE);	/* 使能CC2中断 */
    }
    else if (_CC == 3)
    {
        s_TIM_CallBack3 = (void (*)(void))_pCallBack;

        TIM_SetCompare3(TIM_HARD, cnt_tar);      	/* 设置捕获比较计数器CC3 */
        TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC3);
		TIM_ITConfig(TIM_HARD, TIM_IT_CC3, ENABLE);	/* 使能CC3中断 */
    }
    else if (_CC == 4)
    {
        s_TIM_CallBack4 = (void (*)(void))_pCallBack;

        TIM_SetCompare4(TIM_HARD, cnt_tar);      	/* 设置捕获比较计数器CC4 */
		TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC4);
		TIM_ITConfig(TIM_HARD, TIM_IT_CC4, ENABLE);	/* 使能CC4中断 */
    }
	else
    {
        return;
    }
}

/*
*********************************************************************************************************
*	函 数 名: TIMx_IRQHandler
*	功能说明: TIM 中断服务程序
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/

#ifdef USE_TIM2
void TIM2_IRQHandler(void)
#endif

#ifdef USE_TIM3
void TIM3_IRQHandler(void)
#endif

#ifdef USE_TIM4
void TIM4_IRQHandler(void)
#endif

#ifdef USE_TIM5
void TIM5_IRQHandler(void)
#endif
{
    if (TIM_GetITStatus(TIM_HARD, TIM_IT_CC1))
    {
        TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC1);
        TIM_ITConfig(TIM_HARD, TIM_IT_CC1, DISABLE);	/* 禁能CC1中断 */

        /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
        s_TIM_CallBack1();
    }

    if (TIM_GetITStatus(TIM_HARD, TIM_IT_CC2))
    {
        TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC2);
        TIM_ITConfig(TIM_HARD, TIM_IT_CC2, DISABLE);	/* 禁能CC2中断 */

        /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
        s_TIM_CallBack2();
    }

    if (TIM_GetITStatus(TIM_HARD, TIM_IT_CC3))
    {
        TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC3);
        TIM_ITConfig(TIM_HARD, TIM_IT_CC3, DISABLE);	/* 禁能CC3中断 */

        /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
        s_TIM_CallBack3();
    }

    if (TIM_GetITStatus(TIM_HARD, TIM_IT_CC4))
    {
        TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC4);
        TIM_ITConfig(TIM_HARD, TIM_IT_CC4, DISABLE);	/* 禁能CC4中断 */

        /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
        s_TIM_CallBack4();
    }
}

#endif
/***************************** ?????????? www.armfly.com (END OF FILE) *********************************/
